/**
 * SilvaSerializer
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 * Made by: Mattis DALLEAU
 */
#pragma once

#include "SilvaStdInt"
#include "SilvaBit"

#include <vector>
#include <string>
#include <variant>
#include <stdexcept>
#include <cstring>
#include <array>
#include <optional>
#include <string>

// TODO: Add proper documentation

namespace hl
{
namespace silva
{

using byte_vector = std::vector<byte>;

// u8*4            u64         u8         rodata       u8        rodata
// [magic number]  [size] [[typechartdata]data[0],    [typechart]data[1], ...]
// String: [STRING_TYPE][size][data]
// Array: [BYTE_ARRAY_TYPE][size][data]
// Other: [TYPE][data]
// All sizes and types that validate std::is_arithmetic_v<T> are in network byte order
namespace serializer_metadata
{
    enum TypeChart : u8
    {
        BYTE = 0, // BYTE is a type alias for u8
        U8 = BYTE,
        U16,
        U32,
        U64,
        I8,
        I16,
        I32,
        I64,
        F32,
        F64,
        BOOL8,
        STRING,
        BYTE_ARRAY,

        END = 0xFF
    };

    using TypeValue = std::variant<u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, bool8, std::string, byte_vector, nullptr_t>;

    static inline std::string to_string(const TypeChart &type)
    {
        switch (type)
        {
            // case BYTE: return "BYTE";
            case U8: return "U8";
            case U16: return "U16";
            case U32: return "U32";
            case U64: return "U64";
            case I8: return "I8";
            case I16: return "I16";
            case I32: return "I32";
            case I64: return "I64";
            case F32: return "F32";
            case F64: return "F64";
            case BOOL8: return "BOOL8";
            case STRING: return "STRING";
            case BYTE_ARRAY: return "BYTE_ARRAY";
            case END: return "END(or nullptr)";
            default: return "UNKNOWN";
        }
    }

    static inline std::string to_string(const TypeValue &value)
    {
        // handle vector and string then print the rest
        return std::visit([&value](auto&& arg) -> std::string {
            using T = std::decay_t<decltype(arg)>;
            // print using type chart to string
            if constexpr (std::is_same_v<T, std::string>)
            {
                return "string<'" + arg + "'>";
            }
            else if constexpr (std::is_same_v<T, byte_vector>)
            {
                return "byte_vector<size=" + std::to_string(arg.size()) + ">";
            }
            else if constexpr (std::is_same_v<T, nullptr_t>)
            {
                return "nullptr_t<end_marker>";
            }
            else
            {
                return to_string((TypeChart)value.index()) + "<" + std::to_string(arg) + ">";
            }
        }, value);
    }

    using HeaderSizeType = u64;

    #define DEFAULT_MAGIC_NUMBER_V8_0 0xb1
    #define DEFAULT_MAGIC_NUMBER_V8_1 0xa5
    #define DEFAULT_MAGIC_NUMBER_V8_2 0xed
    #define DEFAULT_MAGIC_NUMBER_V8_3 0xff

    #define DEFAULT_MAGIC_NUMBER_V32 ((DEFAULT_MAGIC_NUMBER_V8_0 << 24) | (DEFAULT_MAGIC_NUMBER_V8_1 << 16) | (DEFAULT_MAGIC_NUMBER_V8_2 << 8) | DEFAULT_MAGIC_NUMBER_V8_3)

    union MagicNumber
    {
        u32 v32;
        byte v8[4];

        MagicNumber(u32 value) : v32(value) {}
        MagicNumber(byte b0, byte b1, byte b2, byte b3) : v8{b0, b1, b2, b3} {}
        MagicNumber(const MagicNumber& other) = default;
        MagicNumber(MagicNumber&& other) = default;
        MagicNumber& operator=(const MagicNumber& other) = default;
        MagicNumber& operator=(MagicNumber&& other) = default;
        MagicNumber() : v32(DEFAULT_MAGIC_NUMBER_V32) {}
    };

    using SizeType = u64;

    static const size_t         MAGIC_NUMBER_SIZE           = sizeof(MagicNumber);
    static const size_t         SIZE_TYPE_SIZE              = sizeof(SizeType);
    static const size_t         HEADER_SIZE_TYPE_SIZE       = sizeof(HeaderSizeType);
    static const size_t         TYPE_CHART_SIZE             = sizeof(TypeChart);
    static const size_t         HEADER_SIZE                 = MAGIC_NUMBER_SIZE + SIZE_TYPE_SIZE;

    using HeaderByteArray = std::array<byte, HEADER_SIZE>;

    static HeaderByteArray make_header(const MagicNumber& magic, const HeaderSizeType& size)
    {
        HeaderByteArray header;
        HeaderSizeType net_size = bit::native_to_network(size);
        MagicNumber net_magic = bit::native_to_network(magic.v32);

        std::memcpy(header.data(), net_magic.v8, MAGIC_NUMBER_SIZE);
        std::memcpy(header.data() + MAGIC_NUMBER_SIZE, &net_size, SIZE_TYPE_SIZE);

        return header;
    }

    static void load_header(const byte_vector& buffer, MagicNumber& magic, HeaderSizeType& size)
    {
        if (buffer.size() < HEADER_SIZE)
        {
            throw std::runtime_error("Buffer is too small to contain the header");
        }

        std::memcpy(magic.v8, buffer.data(), MAGIC_NUMBER_SIZE);

        size = *(HeaderSizeType*)&buffer[MAGIC_NUMBER_SIZE];

        bit::network_to_native_inplace(size);
        bit::network_to_native_inplace(magic.v32);

    }
}

class Serializer
{
private:
    byte_vector m_buffer;
    serializer_metadata::MagicNumber m_magic;

public:
    Serializer() = default;

    Serializer(const Serializer& other) = default;
    Serializer(Serializer&& other) = default;
    Serializer& operator=(const Serializer& other) = default;
    Serializer& operator=(Serializer&& other) = default;

    Serializer(const serializer_metadata::MagicNumber& magic)
        : m_magic(magic)
    {}

    ~Serializer() = default;

private:
    template<typename T, serializer_metadata::TypeChart CTYPE>
    Serializer& _serialize_arithmetic_inplace(const T& value)
    {
        m_buffer.push_back(CTYPE);
        T big_value = bit::native_to_network(value);
        m_buffer.insert(m_buffer.end(), (byte*)&big_value, (byte*)&big_value + sizeof(T));
        return *this;
    }

    template<typename T, serializer_metadata::TypeChart CTYPE>
    Serializer& _serialize_array_inplace(const T& value)
    {
        m_buffer.push_back(CTYPE);
        u64 size = value.size();
        u64 big_size = bit::native_to_network(size);
        m_buffer.insert(m_buffer.end(), (byte*)&big_size, (byte*)&big_size + sizeof(u64));
        m_buffer.insert(m_buffer.end(), value.begin(), value.end());
        return *this;
    }

public:

#define __SILVA_SERIALIZER_MAKE_OPERATOR_MANUAL(CTYPE, FUNC_NAME, TYPE_CHART, OPERATION_TYPE) \
    Serializer& operator<<(const CTYPE& value) { return _serialize_##OPERATION_TYPE##_inplace<CTYPE, serializer_metadata::TypeChart::TYPE_CHART>(value); } \
    Serializer& operator<<(CTYPE&& value)      { return *this << value; } \
    Serializer& serialize_##FUNC_NAME(const CTYPE& value) { return *this << value; } \

#define __SILVA_SERIALIZER_MAKE_OPERATOR_MANUAL_WITH_OP(CTYPE, FUNC_NAME, OPERATION) \
    Serializer& operator<<(const CTYPE& value) { { OPERATION; } return *this; } \
    Serializer& operator<<(CTYPE&& value)      { return *this << value; } \
    Serializer& serialize_##FUNC_NAME(const CTYPE& value) { return *this << value; } \

#define __SILVA_SERIALIZER_MAKE_OPERATOR_ARITHMETIC(TYPE_CHART, CTYPE) \
    __SILVA_SERIALIZER_MAKE_OPERATOR_MANUAL(CTYPE, CTYPE, TYPE_CHART, arithmetic)

#define __SILVA_SERIALIZER_MAKE_OPERATOR_STD_BYTE_ARRAYS(TYPE_CHART, CTYPE, NAME) \
    __SILVA_SERIALIZER_MAKE_OPERATOR_MANUAL(CTYPE, NAME, TYPE_CHART, array)

#define __SILVA_SERIALIZER_MAKE_OPERATOR_UNIMPLEMENTED(CTYPE) \
    __SILVA_SERIALIZER_MAKE_OPERATOR_MANUAL_WITH_OP(CTYPE, CTYPE, (void)value; throw std::runtime_error("Not implemented for " #CTYPE))

    __SILVA_SERIALIZER_MAKE_OPERATOR_ARITHMETIC(U8, u8);
    __SILVA_SERIALIZER_MAKE_OPERATOR_ARITHMETIC(U16, u16);
    __SILVA_SERIALIZER_MAKE_OPERATOR_ARITHMETIC(U32, u32);
    __SILVA_SERIALIZER_MAKE_OPERATOR_ARITHMETIC(U64, u64);
    __SILVA_SERIALIZER_MAKE_OPERATOR_ARITHMETIC(I8, i8);
    __SILVA_SERIALIZER_MAKE_OPERATOR_ARITHMETIC(I16, i16);
    __SILVA_SERIALIZER_MAKE_OPERATOR_ARITHMETIC(I32, i32);
    __SILVA_SERIALIZER_MAKE_OPERATOR_ARITHMETIC(I64, i64);

    __SILVA_SERIALIZER_MAKE_OPERATOR_UNIMPLEMENTED(f32);
    __SILVA_SERIALIZER_MAKE_OPERATOR_UNIMPLEMENTED(f64);

    __SILVA_SERIALIZER_MAKE_OPERATOR_ARITHMETIC(BOOL8, bool8);
    __SILVA_SERIALIZER_MAKE_OPERATOR_STD_BYTE_ARRAYS(STRING, std::string, string);
    __SILVA_SERIALIZER_MAKE_OPERATOR_STD_BYTE_ARRAYS(BYTE_ARRAY, byte_vector, byte_array);

    __SILVA_SERIALIZER_MAKE_OPERATOR_MANUAL_WITH_OP(char *, cstring, *this << std::string(value));
    __SILVA_SERIALIZER_MAKE_OPERATOR_MANUAL_WITH_OP(serializer_metadata::TypeValue, type_value, std::visit([&](auto&& arg) { *this << arg; }, value));

    // wildcard section
    template<typename T>
    Serializer& serialize(const T& value)
    {
        return *this << value;
    }

    template<typename T>
    Serializer& serialize(T&& value)
    {
        return *this << value;
    }

    const byte_vector &get_raw_buffer() const
    {
        return m_buffer;
    }

    byte_vector get_validated_buffer() const
    {
        byte_vector buffer = m_buffer;

        buffer.push_back(serializer_metadata::TypeChart::END);
        serializer_metadata::HeaderByteArray header = serializer_metadata::make_header(m_magic, buffer.size());

        buffer.insert(buffer.begin(), header.begin(), header.end());

        return buffer;
    }
};

class Deserializer
{
private:
    byte_vector m_buffer;

    size_t m_index = 0;

public:
    Deserializer() = default;
    ~Deserializer() = default;

    Deserializer(const byte_vector& buffer,
                const serializer_metadata::MagicNumber &expected_magic,
                std::optional<byte_vector>& rest_buffer)
        : m_buffer(buffer)
    {
        serializer_metadata::HeaderSizeType size;
        serializer_metadata::MagicNumber magic;

        serializer_metadata::load_header(buffer, magic, size);

        if (magic.v32 != expected_magic.v32)
        {
            auto p = serializer_metadata::MagicNumber();
            throw std::runtime_error("Magic number does not match the expected magic number");
        }

        m_index = serializer_metadata::HEADER_SIZE;

        if (m_index + size > m_buffer.size())
        {
            throw std::runtime_error("Buffer is too small to contain the data");
        }

        if (m_buffer[m_index + size - sizeof(serializer_metadata::TypeChart)] != serializer_metadata::TypeChart::END)
        {
            throw std::runtime_error("Missing END marker");
        }

        // Extract the rest of the buffer that will be not used by the Deserializer
        if (m_index + size < m_buffer.size())
        {
            rest_buffer = byte_vector(m_buffer.begin() + m_index + size, m_buffer.end());
            // drop the end of the buffer that we stored in rest_buffer
            m_buffer.erase(m_buffer.begin() + m_index + size, m_buffer.end());
        }
        else
        {
            rest_buffer = std::nullopt;
        }
    }

    Deserializer(const Deserializer& other) = default;
    Deserializer(Deserializer&& other) = default;
    Deserializer& operator=(const Deserializer& other) = default;
    Deserializer& operator=(Deserializer&& other) = default;

private:
    template<typename T, serializer_metadata::TypeChart CTYPE>
    Deserializer& _deserialize_inplace_arithmetic(T& value)
    {
        static const size_t MINIMUM_SIZE = sizeof(serializer_metadata::TypeChart) + sizeof(T);

        if (m_index + MINIMUM_SIZE > m_buffer.size())
        {
            throw std::runtime_error("Buffer is too small to contain the value");
        }
        else if (m_buffer[m_index] != CTYPE)
        {
            throw std::runtime_error("Type does not match the expected type");
        }

        value = *reinterpret_cast<T*>(&m_buffer[m_index + sizeof(serializer_metadata::TypeChart)]);
        m_index += sizeof(serializer_metadata::TypeChart) + sizeof(T);

        // avoid making conversion for single byte types
        if constexpr (std::is_arithmetic_v<T> && sizeof(T) > 1)
            bit::network_to_native_inplace(value);

        return *this;
    }

    template<typename T, serializer_metadata::TypeChart CTYPE>
    Deserializer& _deserialize_inplace_array(T& value)
    {
        static const size_t MINIMUM_SIZE = sizeof(serializer_metadata::TypeChart) + sizeof(serializer_metadata::SizeType);

        if (m_index + MINIMUM_SIZE > m_buffer.size())
        {
            throw std::runtime_error("Buffer is too small to contain the value");
        }
        else if (m_buffer[m_index] != CTYPE)
        {
            throw std::runtime_error("Type does not match the expected type");
        }

        serializer_metadata::SizeType size = *reinterpret_cast<serializer_metadata::SizeType*>(&m_buffer[m_index + sizeof(serializer_metadata::TypeChart)]);
        bit::network_to_native_inplace(size);

        if (m_index + size + MINIMUM_SIZE > m_buffer.size())
        {
            throw std::runtime_error("Buffer is too small to contain the value");
        }

        m_index += MINIMUM_SIZE;


        value = T(m_buffer.begin() + m_index, m_buffer.begin() + m_index + size);
        m_index += size;

        return *this;
    }

public:
#define __SILVA_DESERIALIZER_OPERATOR_NAMED(CTYPE, METADATA_TYPE, member_func_name, method_type) \
    CTYPE get_##member_func_name() { CTYPE value; _deserialize_inplace_##method_type<CTYPE, serializer_metadata::TypeChart::METADATA_TYPE>(value); return value; } \
    Deserializer& operator>>(CTYPE& value) { return _deserialize_inplace_##method_type<CTYPE, serializer_metadata::TypeChart::METADATA_TYPE>(value); } \
    Deserializer& get_##member_func_name##_inplace(CTYPE& value) { return *this >> value; }

#define __SILVA_DESERIALIZER_OPERATOR_CTYPE_ARITHMETIC(CTYPE, METADATA_TYPE) \
    __SILVA_DESERIALIZER_OPERATOR_NAMED(CTYPE, METADATA_TYPE, CTYPE, arithmetic)

#define __SILVA_DESERIALIZER_OPERATOR_CTYPE_UNIMPLEMENTED(CTYPE, METADATA_TYPE, member_func_name, method_type) \
    CTYPE get_##member_func_name() { throw std::runtime_error("Not implemented for " #CTYPE); } \
    Deserializer& operator>>(CTYPE&) { throw std::runtime_error("Not implemented for " #CTYPE); } \
    Deserializer& get_##member_func_name##_inplace(CTYPE&) { throw std::runtime_error("Not implemented for " #CTYPE); }

    __SILVA_DESERIALIZER_OPERATOR_CTYPE_ARITHMETIC(u8, U8);
    __SILVA_DESERIALIZER_OPERATOR_CTYPE_ARITHMETIC(u16, U16);
    __SILVA_DESERIALIZER_OPERATOR_CTYPE_ARITHMETIC(u32, U32);
    __SILVA_DESERIALIZER_OPERATOR_CTYPE_ARITHMETIC(u64, U64);
    __SILVA_DESERIALIZER_OPERATOR_CTYPE_ARITHMETIC(i8, I8);
    __SILVA_DESERIALIZER_OPERATOR_CTYPE_ARITHMETIC(i16, I16);
    __SILVA_DESERIALIZER_OPERATOR_CTYPE_ARITHMETIC(i32, I32);
    __SILVA_DESERIALIZER_OPERATOR_CTYPE_ARITHMETIC(i64, I64);

    __SILVA_DESERIALIZER_OPERATOR_CTYPE_UNIMPLEMENTED(f32, F32, f32, arithmetic);
    __SILVA_DESERIALIZER_OPERATOR_CTYPE_UNIMPLEMENTED(f64, F64, f64, arithmetic);

    __SILVA_DESERIALIZER_OPERATOR_CTYPE_ARITHMETIC(bool8, BOOL8);

    __SILVA_DESERIALIZER_OPERATOR_NAMED(std::string, STRING, string, array);
    __SILVA_DESERIALIZER_OPERATOR_NAMED(byte_vector, BYTE_ARRAY, byte_array, array);

#undef __SILVA_DESERIALIZER_OPERATOR_NAMED
#undef __SILVA_DESERIALIZER_OPERATOR_CTYPE_ARITHMETIC
#undef __SILVA_DESERIALIZER_OPERATOR_CTYPE_UNIMPLEMENTED

    Deserializer& operator>>(serializer_metadata::TypeValue& value)
    {
        if (m_index + sizeof(serializer_metadata::TypeChart) > m_buffer.size())
        {
            throw std::runtime_error("Buffer is too small to contain the value");
        }
        switch ((serializer_metadata::TypeChart)m_buffer[m_index])
        {
            #define __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(TYPE, CTYPE) \
            case serializer_metadata::TypeChart::TYPE: { \
                value = get_##CTYPE(); \
                break; \
            }
            
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(U8, u8);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(U16, u16);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(U32, u32);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(U64, u64);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(I8, i8);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(I16, i16);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(I32, i32);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(I64, i64);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(F32, f32);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(F64, f64);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(BOOL8, bool8);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(STRING, string);
            __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE(BYTE_ARRAY, byte_array);

            #undef __SILVA_DESERIALIZER_SWITCH_CASE_TYPE_VALUE

            case serializer_metadata::TypeChart::END:
                value = nullptr;
                m_index += sizeof(serializer_metadata::TypeChart);
                break;

            default:
                throw std::runtime_error("Unknown type");
                break;
        }
        return *this;
    }

    serializer_metadata::TypeValue get_type_value()
    {
        serializer_metadata::TypeValue value;
        *this >> value;
        return value;
    }

    const byte_vector& get_buffer() const
    {
        return m_buffer;
    }

    bool is_at_end() const
    {
        return m_index >= m_buffer.size();
    }

    std::size_t get_index() const
    {
        return m_index;
    }

    void seek(const std::size_t &index)
    {
        if (index >= m_buffer.size())
        {
            throw std::runtime_error("Index out of bounds");
        }
        m_index = index;
    }

    // to make it compatible with std::for_each

    class iterable
    {
    private:
        Deserializer &_deserializer;
        serializer_metadata::TypeValue _last_value;
        std::size_t _index;
        const std::size_t _original_index;

    public:
        iterable(Deserializer &deserializer, std::size_t index = 0)
            : _deserializer(deserializer)
            , _index(index)
            , _original_index(deserializer.get_index())
        {
            if (_index == 0) {
                _index = serializer_metadata::HEADER_SIZE;
            }
        }

        bool operator!=(const iterable& other) const
        {
            return _index != other._index;
        }

        bool operator==(const iterable& other) const
        {
            return !(*this != other);
        }

        iterable &operator++()
        {
            _deserializer.seek(_index);

            try {
                _last_value = _deserializer.get_type_value();
                _index = _deserializer.get_index();
                _deserializer.seek(_original_index);
            } catch (const std::runtime_error& e) {
                _deserializer.seek(_original_index);
                throw e;
            }

            return *this;
        }

        iterable& operator+=(const std::size_t& value)
        {
            for (std::size_t i = 0; i < value; i++)
            {
                ++(*this);
            }
            return *this;
        }

        iterable operator+(const std::size_t& value)
        {
            return iterable(*this) += value;
        }

        iterable &operator--() = delete;
        iterable operator--(int) = delete;
        iterable operator-(const std::size_t& value) = delete;
        iterable operator-=(const std::size_t& value) = delete;

        serializer_metadata::TypeValue operator*()
        {
            return _last_value;
        }

        const serializer_metadata::TypeValue &operator*() const
        {
            return _last_value;
        }
    };

    iterable begin()
    {
        return iterable(*this);
    }

    iterable end()
    {
        return iterable(*this, m_buffer.size());
    }
};

}
}

namespace std
{
    std::string to_string(const hl::silva::serializer_metadata::TypeChart &type)
    {
        return hl::silva::serializer_metadata::to_string(type);
    }

    std::string to_string(const hl::silva::serializer_metadata::TypeValue &value)
    {
        return hl::silva::serializer_metadata::to_string(value);
    }
}
