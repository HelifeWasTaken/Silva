#include <type_traits>
#include <bit>

namespace hl
{
namespace silva
{
namespace bit
{

enum class endian
{
#if __cplusplus >= 202002L
    big = (int)std::endian::big,
    little = (int)std::endian::little,
    native = (int)std::endian::native,
#else
    big = __ORDER_BIG_ENDIAN__,
    little = __ORDER_LITTLE_ENDIAN__,
    native = __BYTE_ORDER__,
#endif

#ifdef SILVA_BIT_ENABLE_NETWORK_AS_LITTLE
#warning "Using little endianess on the network is not a standard procedure!"
    network = little
#else
    network = big
#endif
};

// Big Endian
template<typename T>
using enable_when_arithmetic = std::enable_if_t<std::is_arithmetic<T>::value, bool>;

template<typename T, enable_when_arithmetic<T> = true>
static inline constexpr T swap_endian(const T &value)
{
#if defined(__GNUC__) || defined(__clang__)
    if constexpr (sizeof(T) == 1)
    {
        return value;
    }
    else if constexpr (sizeof(T) == 2)
    {
        return __builtin_bswap16(value);
    }
    else if constexpr (sizeof(T) == 4)
    {
        return __builtin_bswap32(value);
    }
    else if constexpr (sizeof(T) == 8)
    {
        return __builtin_bswap64(value);
    }
    else if constexpr (sizeof(T) == 16)
    {
        return __builtin_bswap128(value);
    }
#elif defined(_MSC_VER)
    if constexpr (sizeof(T) == 1)
    {
        return value;
    }
    else if constexpr (sizeof(T) == 2)
    {
        return _byteswap_ushort(value);
    }
    else if constexpr (sizeof(T) == 4)
    {
        return _byteswap_ulong(value);
    }
    else if constexpr (sizeof(T) == 8)
    {
        return _byteswap_uint64(value);
    }
    else if constexpr (sizeof(T) == 16)
    {
        static_assert(sizeof(T) == 16, "Unsupported size for _byteswap128 using MSVC");
    }
#else
    T result = 0;
    for (size_t i = 0; i < sizeof(T); i++)
    {
        result |= ((value >> (i * 8)) & 0xFF) << ((sizeof(T) - i - 1) * 8);
    }
    return result;
#endif
}

template<typename T, enable_when_arithmetic<T> = true>
static inline constexpr T to_big_endian(const T &value)
{
    return endian::native == endian::big ? value : _swap_endian(value);
}

template<typename T, enable_when_arithmetic<T> = true>
static inline constexpr void to_big_endian_inplace(T &value)
{
    value = to_big_endian(value);
}

// Little Endian
template<typename T, enable_when_arithmetic<T> = true>
static inline constexpr T to_little_endian(const T &value)
{
    return endian::native == endian::little ? value : _swap_endian(value);
}

template<typename T, enable_when_arithmetic<T> = true>
static inline constexpr void to_little_endian_inplace(T &value)
{
    value = to_little_endian(value);
}

// Network

template<typename T, enable_when_arithmetic<T> = true>
static inline constexpr T native_to_network(const T &value)
{
    if constexpr(endian::native != endian::network) {
        return swap_endian(value);
    }
    return value;
}

template<typename T, enable_when_arithmetic<T> = true>
static inline constexpr T network_to_native(const T &value)
{
    return native_to_network(value); // actually does the same (is the same as calling byteswap but only checks if the endianess is already big)
}

template<typename T, enable_when_arithmetic<T> = true>
static inline constexpr void native_to_network_inplace(T &value)
{
    value = native_to_network(value);
}

template<typename T, enable_when_arithmetic<T> = true>
static inline constexpr void network_to_native_inplace(T &value)
{
    value = network_to_native(value);
}

} // namespace bit
} // namespace silva
} // namespace hl