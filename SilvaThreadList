/**
 * SilvaThreadList
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 * Made by: Mattis DALLEAU
 */

#pragma once

#include <vector>
#include <thread>
#include <optional>
#include <functional>
#include <mutex>
#include <queue>
#include <atomic>
#include <condition_variable>
#include <memory>

namespace hl
{
namespace silva 
{

#ifndef SILVA_THREAD_LIST_DEFAULT_SIZE
#define SILVA_THREAD_LIST_DEFAULT_SIZE 20
#endif

/**
 * @brief SilvaThreadList
 */
class SilvaThreadList
{
private:
    std::vector<std::thread> _threads;
    std::queue<std::size_t> _available_indexes;
    std::queue<std::size_t> _to_release;


    std::thread _thread_push;
    std::thread _thread_release;
    mutable std::mutex _mutex;

    std::queue<std::function<void(void)>> _queue;

    std::atomic_bool _running = true;
    std::atomic_size_t _running_threads_count = 0;

    /**
     * @brief _has_finished Checks whether all given tasks have finished
     * @tparam Lock Whether it is required to lock the mutex
     * @return true all tasks have finished
     * @return false some tasks are still running
     */
    template<bool Lock=false>
    inline bool _has_finished() const
    {
        if constexpr (Lock == false) {
            return _to_release.empty() == true &&
                    _queue.empty() == true &&
                    _running_threads_count == 0;
        } else {
            std::lock_guard<std::mutex> lock(this->_mutex);
            return _has_finished<false>();
        }
    }

public:

    /**
     * @brief SilvaThreadList
     * @param size Number that can be used concurrently in this space
     */
    SilvaThreadList(const std::size_t& size=SILVA_THREAD_LIST_DEFAULT_SIZE)
    {
        this->_threads.reserve(size);

        for (std::size_t i = 0; i < size; i++)
        {
            this->_threads.push_back(std::thread());
            this->_available_indexes.push(i);
        }

        this->_thread_push = std::thread(
            [this]
            (void) -> void
            {
                while (this->_running == true)
                {
                    std::lock_guard<std::mutex> lock(this->_mutex);

                    if (this->_running == false && this->_has_finished<false>() == true)
                    {
                        return;
                    }

                    if (this->_available_indexes.empty() == true)
                        continue;

                    if (this->_queue.empty() == false)
                    {
                        this->_running_threads_count++;
                        this->_queue.front()();
                        this->_queue.pop();
                    }
                }
            }
        );

        this->_thread_release = std::thread(
            [this]
            (void) -> void
            {
                while (this->_running == true)
                {
                    std::lock_guard<std::mutex> lock(this->_mutex);

                    if (this->_running == false && this->_has_finished<false>() == true)
                    {
                        return;
                    }

                    while (this->_to_release.empty() == false)
                    {
                        const std::size_t index = this->_to_release.front();
                        this->_threads[index].join();
                        this->_to_release.pop();
                        this->_available_indexes.push(index);
                        this->_running_threads_count--;
                    }
                }
            }
        );
    }

    /**
     * @brief ~SilvaThreadList
     * Stops all threads and joins them
     */
    ~SilvaThreadList()
    {
        join();
        _running = false;
        _thread_push.join();
        _thread_release.join();
    }

    /**
     * @brief start Push to the queue a new task that will be executed by a thread when one is available
     * @tparam F The callback function type
     * @tparam Args The arguments types of the callback function
     * @param f The callback function
     * @param args The arguments of the callback function
     * @return void
     */
    template<typename F, typename... Args>
    void start(F&& f, Args&&... args)
    {
        std::lock_guard<std::mutex> lock(_mutex);

        if (_running == false) {
            return;
        }

        // Index is popped after the callback
        this->_queue.push(
            [this, f, args...]
            (void) -> void
            {
                const std::size_t index = this->_available_indexes.front();
                this->_available_indexes.pop();

                this->_threads[index] = std::thread(
                    [this, index, f, args...]
                    (void) -> void
                    {
                        f(args...);
                        std::lock_guard<std::mutex> lock(this->_mutex);
                        this->_to_release.push(index);
                    }
                );

            }
        );
    }

    /**
     * @brief join Waits until all tasks have finished
     * @return void
     */
    void join(void)
    {
        while (!_has_finished<true>())
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
    }

    /**
     * @brief stop Stops all threads
     * @param remove_pending_queue Whether to remove all pending tasks
     * @return void
     */
    void stop(bool remove_pending_queue=false)
    {
        std::lock_guard<std::mutex> lock(_mutex);
        _running = false;

        if (remove_pending_queue)
        {
            while (!_queue.empty())
            {
                _queue.pop();
            }

        }
    }
};

/**
 * @brief GPUThreadSim A class that simulates the behavior of a GPU (inspired by CUDA)
 */
class GPUThreadSim
{
public:
    /**
     * @brief ThreadIndex A structure that represents the index of a thread in a 3D space
     */
    struct ThreadIndex {
        unsigned int x, y, z;
        constexpr ThreadIndex(unsigned int x, unsigned int y, unsigned int z=1)
            : x(x), y(y), z(z)
        {};

        constexpr ThreadIndex(const ThreadIndex& index) = default;
        constexpr ThreadIndex& operator=(const ThreadIndex& index) = default;

        constexpr ThreadIndex(void)
            : x(0), y(0), z(0)
        {};

        constexpr bool operator==(const ThreadIndex& index) const
        {
            return x == index.x && y == index.y && z == index.z;
        }

        constexpr bool operator!=(const ThreadIndex& index) const
        {
            return !(*this == index);
        }

        class iterator;
        struct iterable;
    };

    class ThreadIndex::iterator {
    private:
        ThreadIndex _index;
        ThreadIndex _size;

    public:
        constexpr iterator(const ThreadIndex& index, const ThreadIndex& size)
            : _index(index), _size(ThreadIndex(size.x - 1, size.y - 1, size.z - 1))
        {
            if (_index.x > _size.x || _index.y > _size.y || _index.z > _size.z)
            {
                _index = _size;
            }
        }

        constexpr iterator& operator++(void)
        {
            if (_index.x < _size.x)
            {
                _index.x++;
            }
            else if (_index.y < _size.y)
            {
                _index.x = 0;
                _index.y++;
            }
            else if (_index.z < _size.z)
            {
                _index.x = 0;
                _index.y = 0;
                _index.z++;
            }
            return *this;
        }

        constexpr bool operator!=(const iterator& it) const
        {
            return _index != it._index;
        }

        constexpr const ThreadIndex& operator*(void) const
        {
            return _index;
        }
    };

    struct ThreadIndex::iterable {
        const ThreadIndex& _index;
        const ThreadIndex& _size;

        iterable(const ThreadIndex& size)
            : _index(ThreadIndex()), _size(size)
        {}

        iterable(const ThreadIndex& index, const ThreadIndex& size)
            : _index(index), _size(size)
        {}

        ThreadIndex::iterator begin(void) const
        {
            return ThreadIndex::iterator(_index, _size);
        }

        ThreadIndex::iterator end(void) const
        {
            return ThreadIndex::iterator(_size, _size);
        }
    };

    /**
     * @brief GPUCallback A callback function that is called by a thread
     * @tparam Args The arguments types of the callback function
     */
    template<typename... Args>
    using GPUCallback = std::function<void(const ThreadIndex&, Args...)>;

    /**
     * @brief GPUIndexFormat A function that formats the index of a thread to a specific format
     */
    using GPUIndexFormat = std::function<ThreadIndex(const ThreadIndex&)>;

    // Methods to format the index of a thread
    static inline constexpr ThreadIndex XYZ(const ThreadIndex& index) { return index; };
    static inline constexpr ThreadIndex XZY(const ThreadIndex& index) { return ThreadIndex(index.x, index.z, index.y); };
    static inline constexpr ThreadIndex YXZ(const ThreadIndex& index) { return ThreadIndex(index.y, index.x, index.z); };
    static inline constexpr ThreadIndex YZX(const ThreadIndex& index) { return ThreadIndex(index.y, index.z, index.x); };
    static inline constexpr ThreadIndex ZXY(const ThreadIndex& index) { return ThreadIndex(index.z, index.x, index.y); };
    static inline constexpr ThreadIndex ZYX(const ThreadIndex& index) { return ThreadIndex(index.z, index.y, index.x); };

private:
    SilvaThreadList _thread_list;

public:
    /**
     * @brief GPUThreadSim
     * @param thread_count The number of threads that can be used concurrently
     */
    GPUThreadSim(unsigned int thread_count=SILVA_THREAD_LIST_DEFAULT_SIZE)
        : _thread_list(thread_count)
    {}

    /**
     * @brief start_fmt Starts the simulation with a specific format
     * @tparam Args The arguments types of the callback function
     * @param size The size of the 3D space
     * @param callback The callback function
     * @param format The format of the index of a thread
     * @param args The arguments of the callback function
     * @return void
     */
    template<typename... Args>
    void start_fmt(const ThreadIndex& size,
        GPUCallback<Args...>&& callback,
        GPUIndexFormat&& format,
        Args&&... args)

    {
        for (const ThreadIndex& index : ThreadIndex::iterable(size))
        {
            _thread_list.start(
                [](const ThreadIndex& index, GPUCallback<Args...>&& callback, Args&&... args)
                {
                    callback(index, std::forward<Args>(args)...);
                }, format(index), std::forward<GPUCallback<Args...>>(callback), std::forward<Args>(args)...
            );
        }
    }

    /**
     * @brief start Starts the simulation
     * @tparam Args The arguments types of the callback function
     * @param size The size of the 3D space
     * @param callback The callback function
     * @param args The arguments of the callback function
     * @return void
     */
    template<typename... Args>
    void start(const ThreadIndex& size,
        GPUCallback<Args...>&& callback,
        Args&&... args)
    {
        start_fmt(size, std::forward<GPUCallback<Args...>>(callback), XYZ, std::forward<Args>(args)...);
    }

    /**
     * @brief Join all threads stop the simulation and wait until all tasks have finished
     * @return void
     */
    ~GPUThreadSim()
    {
        _thread_list.stop(false);
        join();
    }

    /**
     * @brief join Waits until all current tasks have finished
     * @return void
     */
    void join(void)
    {
        _thread_list.join();
    }

    /**
     * @brief stop Stops the simulation and remove all pending tasks
     *             (Cannot stop the already started tasks but will stop the pending ones and remove them)
     * @return void
     */
    void stop(void)
    {
        _thread_list.stop(true);
    }
};

}
}
